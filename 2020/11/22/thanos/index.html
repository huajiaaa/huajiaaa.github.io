<!DOCTYPE html><html lang="zh_CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Thanos | 冰箱里有啤酒和咖啡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Thanos</h1><a id="logo" href="/.">冰箱里有啤酒和咖啡</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Thanos</h1><div class="post-meta">Nov 22, 2020<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><p>Thanos 是可以被组合成一个高可用和无限扩展的 metric 系统的一套组件的集合, 可将其无缝添加到现有的 prometheus 部署之上.</p>
<p>Thanos 凭借着 Prometheus 2.0 存储格式（即 tsdb 3.0）得以在任何对象存储中经济高效地存储历史数据，同时可以快速查询。此外，它提供了所有 Prometheus 的全局查询视角，并且可以即时合并 Prometheus HA 对中的数据（即合并冗余数据）。</p>
<p>Thanos 的具体目标是：</p>
<ul>
<li>全局的 metric 查询视角</li>
<li>metric 的无限存储/保留</li>
<li>包括 prometheus 在内的组件的的高可用性</li>
</ul>
<h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><ul>
<li>全局的查询视角, 横跨所有连接的 prometheus 服务器</li>
<li>对于高可用 prometheus 服务器, 可进行删除重复数据和合并收集的指标</li>
<li>与现有的 prometheus 部署无缝集成</li>
<li>任何对象存储都是其唯一的, 可选的依赖</li>
<li>对历史数据进行降采样以大幅提高查询速度</li>
<li>跨集群联邦</li>
<li>容错查询路由</li>
<li>简单的 gRPC Store API, 可跨所有 metric 数据进行统一的数据访问</li>
<li>为自定义 metric 提供了轻松的集成点</li>
</ul>
<h1 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h1><ul>
<li>每个子命令都应该做一件事并把它做好</li>
<li>编写可以协同工作的组件</li>
<li>让组件易于阅读、编写和运行</li>
</ul>
<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="https://raw.githubusercontent.com/thanos-io/thanos/master/docs/img/arch.jpg" alt="Thanos 架构"></p>
<p>Thanos 是由多个组件组成的集群体统, 这些组件可大体分类如下：</p>
<ul>
<li>Metric sources</li>
<li>Stores</li>
<li>Queriers</li>
</ul>
<h2 id="Metric-Sources"><a href="#Metric-Sources" class="headerlink" title="Metric Sources"></a>Metric Sources</h2><p>数据源是对于一个生成/采集 metric 数据的组件的非常笼统的定义.  可以通过 gRPC API 查询这些 metric 数据.</p>
<p>Thanos 提供了两个充当数据源的组件: prometheus sidecar 和 rule nodes.</p>
<h3 id="sidecar"><a href="#sidecar" class="headerlink" title="sidecar"></a>sidecar</h3><p>sidecar 必须与 Prometheus 一起部署, 实现将 Prometheus 监控数据上传到对象存储, 并允许 Querier 组件查询 Prometheus 数据。</p>
<h3 id="rule-nodes"><a href="#rule-nodes" class="headerlink" title="rule nodes"></a>rule nodes</h3><p>rule node 基于 Prometheus 的存储引擎实现了 gRPC API.</p>
<h3 id="Metric-Data-Backup"><a href="#Metric-Data-Backup" class="headerlink" title="Metric Data Backup"></a>Metric Data Backup</h3><p>metric 数据长期存储的数据源通过 prometheus 2.0 存储引擎实现. </p>
<p>存储引擎会定期地生成固定时间范围内的不可变数据块.<br>数据块是一个具有大文件的目录, 其中包含了所有版本数据和检索数据所需的持久索引, 格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">01BX6V6TY06G5MFQ0GPH7EMXRH</span><br><span class="line">├── chunks</span><br><span class="line">│   ├── 000001</span><br><span class="line">│   ├── 000002</span><br><span class="line">│   └── 000003</span><br><span class="line">├── index</span><br><span class="line">└── meta.json</span><br></pre></td></tr></table></figure>

<p>数据块的顶层目录是一个 ULID, 它像一个 UUID 但是是字典序的并且能够解码成创建时间.</p>
<ul>
<li>chunks 目录下包含多个块, 每个块中存储了一个 series, 大概有几百兆大小.</li>
<li>index 文件包含通过标签和数据块位置查询特定的时间序列所需的所有信息.</li>
<li>meta.json 包含了有关数据块的元信息, 比如: 统计信息、时间范围和压缩等级.</li>
</ul>
<p>这些块文件可以备份到一个对象存储, 并且能够被其他的组件查询. 当 prometheus 服务器或存储引擎创建数据的时候, 这些数据会被上传.<br>meta.json 文件能够被 thanos 扩展, 可以向其中添加 thanos 特殊的元信息. 当前, 它包括该数据块的生产者赋予的外部标签. 这些标签有助于过滤掉数据块以进行查询, 而无需访问它们的数据文件. </p>
<p>meta.json 在 sidecar 上传数据的时候被更新.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌────────────┬─────────┐         ┌────────────┬─────────┐     ┌─────────┐</span><br><span class="line">│ Prometheus │ Sidecar │   ...   │ Prometheus │ Sidecar │     │   Rule  │</span><br><span class="line">└────────────┴────┬────┘         └────────────┴────┬────┘     └┬────────┘</span><br><span class="line">                  │                                │           │</span><br><span class="line">                Blocks                           Blocks      Blocks</span><br><span class="line">                  │                                │           │</span><br><span class="line">                  v                                v           v</span><br><span class="line">              ┌──────────────────────────────────────────────────┐</span><br><span class="line">              │                   Object Storage                 │</span><br><span class="line">              └──────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="Stores"><a href="#Stores" class="headerlink" title="Stores"></a>Stores</h2><p>Store 组件充当对象存储的网关, 它在对象存储上实现了与数据源相同的 gRPC api 以提供了对于所有 metric 数据的访问.<br>它持续地同步桶中已存在的块, 并且把对 metric 数据的请求转换成对象存储的请求. 它实现了多种策略从而最小化对对象存储的请求/查询数量, 例如通过元数据(时间范围和标签)过滤相关块, 并且缓存频繁查找的索引(index).</p>
<p>存储节点知道文件的布局并且把数据请求转换成可以最小化查询对象存储数量请求的计划. 每个请求可能一次拉取数十万个 chunk. 这对于满足对对象存储的有限请求的大型查询至关重要.</p>
<p>目前只有索引数据被缓存. 虽然 chunk 数据也可以缓存, 但是对空间的要求要大几个数量级. 在当前的状态下, 从对象存储中获取数据仅占端到端延迟的一小部分. 因此, 暂时还没有动力把 chunk 缓存下来.</p>
<h2 id="Stores-amp-Data-Sources-It’s-all-the-same"><a href="#Stores-amp-Data-Sources-It’s-all-the-same" class="headerlink" title="Stores &amp; Data Sources - It’s all the same"></a>Stores &amp; Data Sources - It’s all the same</h2><p>由于存储节点和数据源都实现了相同的 gRPC api, 所以客户端可以把它们视为同等的, 不需要关注正在查询哪个组件. Store api 的每个实现者会发布有关它们提供数据的元信息, 这使得客户端在进行特定数据的查询时, 可以最大程度地减少扇出的节点集.<br>本质上讲, Store API 允许通过 PromQL 查询数据. 它返回的是在 block 中查到的样本压缩块. 它纯粹是一个数据查询的 API, 而不提供复杂的查询执行.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────┐  ┌────────────┬─────────┐   ┌────────────┐</span><br><span class="line">│ Google Cloud Storage │  │ Prometheus │ Sidecar │   │    Rule    │</span><br><span class="line">└─────────────────┬────┘  └────────────┴────┬────┘   └─┬──────────┘</span><br><span class="line">                  │                         │          │</span><br><span class="line">         Block File Ranges                  │          │</span><br><span class="line">                  │                     Store API      │</span><br><span class="line">                  v                         │          │</span><br><span class="line">                ┌──────────────┐            │          │</span><br><span class="line">                │     Store    │            │      Store API</span><br><span class="line">                └────────┬─────┘            │          │</span><br><span class="line">                         │                  │          │</span><br><span class="line">                     Store API              │          │</span><br><span class="line">                         │                  │          │</span><br><span class="line">                         v                  v          v</span><br><span class="line">                       ┌──────────────────────────────────┐</span><br><span class="line">                       │              Client              │</span><br><span class="line">                       └──────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h2 id="Query-Layer"><a href="#Query-Layer" class="headerlink" title="Query Layer"></a>Query Layer</h2><p>Queriers 是无状态的并且可以水平扩展实例, 它在集群中暴露出的 Store APIs 之上实现了 PromQL. querier 加入集群后, 能够发现所有 data sources 和 store nodes. 同样, rule nodes 也可以发现 querier nodes, 从而评估 recording rules 和 alerting rules.<br>基于 store nodes 和 source nodes 的元信息, Queriers 会尝试最小化查询扇出以获取特定的查询数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────┐  ┌────────────┬─────────┐   ┌────────────┐</span><br><span class="line">│    Store Node    │  │ Prometheus │ Sidecar │   │    Rule    │</span><br><span class="line">└─────────────┬────┘  └────────────┴────┬────┘   └─┬──────────┘</span><br><span class="line">              │                         │          │</span><br><span class="line">              │                         │          │</span><br><span class="line">              │                         │          │</span><br><span class="line">              v                         v          v</span><br><span class="line">        ┌─────────────────────────────────────────────────────┐</span><br><span class="line">        │                      Query layer                    │</span><br><span class="line">        └─────────────────────────────────────────────────────┘</span><br><span class="line">                ^                  ^                  ^</span><br><span class="line">                │                  │                  │</span><br><span class="line">       ┌────────┴────────┐  ┌──────┴─────┐       ┌────┴───┐</span><br><span class="line">       │ Alert Component │  │ Dashboards │  ...  │ Web UI │</span><br><span class="line">       └─────────────────┘  └────────────┘       └────────┘</span><br></pre></td></tr></table></figure>

<h2 id="Compactor"><a href="#Compactor" class="headerlink" title="Compactor"></a>Compactor</h2><p>compactor 是不参与 Thanos 集群的单例进程, 其作用是压缩远程存储中数据的数据/降低远程存储中数据的精度. 这显著减少了存储桶中的总存储大小、存储节点上的负载以及从存储桶中获取查询数据所需的请求数量。</p>
<h1 id="Scaling"><a href="#Scaling" class="headerlink" title="Scaling"></a>Scaling</h1><p>Thanos 的组件中并未提供任何分片的方式. </p>
<p>唯一可显式扩展的是查询节点, 因为它们是无状态的, 可任意扩展. </p>
<p>通过外部对象存储系统可确保存储容量的扩展.<br>存储节点、规则节点和压缩节点都预期能够在单实例或高可用 pair 中大规模地扩展, 但目前还没有必要.</p>
<h1 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h1><p>在现有的 Prometheus 之上部署 Thanos, 所带来的唯一开销是从对象存储和存储节点中存储数据和查询数据.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/thanos-io/thanos" target="_blank" rel="noopener">https://github.com/thanos-io/thanos</a></li>
<li><a href="https://thanos.io/tip/thanos/design.md/#" target="_blank" rel="noopener">https://thanos.io/tip/thanos/design.md/#</a></li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Author: </strong>huajiaaa</li><li class="post-copyright-link"><strong>Blog Link: </strong><a href="/2020/11/22/thanos/">http://yoursite.com/2020/11/22/thanos/</a></li><li class="post-copyright-license"><strong>Copyright Declaration: </strong>本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="/tags/大监控/">大监控</a></div><div class="post-nav"><a class="pre" href="/2020/11/22/thanos-Querier/">Thanos 的查询过程</a><a class="next" href="/2019/09/15/2019-9-15/"></a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '9068028cdf34808763a3',
  clientSecret: '6a7ac29d31bad8013d5348db4292442adfc4c097',
  repo: 'issues',
  owner: 'huajiaaa',
  admin: ['huajiaaa'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yoursite.com"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/大监控/" style="font-size: 15px;">大监控</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/thanos/" style="font-size: 15px;">thanos</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>