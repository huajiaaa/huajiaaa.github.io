<!DOCTYPE html><html lang="zh_CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Thanos-Querier | 冰箱里有啤酒</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Thanos-Querier</h1><a id="logo" href="/.">冰箱里有啤酒</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Thanos-Querier</h1><div class="post-meta">Nov 22, 2020<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="post-content"><p>Thanos Querier 实现了 prometheus HTTP v1 API, 通过 PromQL 查询集群中的数据.</p>
<p>简而言之，它通过 store api 收集所需的数据, 计算查询并返回结果.</p>
<p>Querier 是完全无状态的并且可以水平扩展。</p>
<h3 id="Global-View"><a href="#Global-View" class="headerlink" title="Global View"></a>Global View</h3><p>由于对于 Querier 而言，“后端”是实现了 gRPC StoreAPI 的所有组件，因此我们可以从任意数量的不同存储中聚合数据，例如:</p>
<ul>
<li>Prometheus (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/sidecar.md" target="_blank" rel="noopener">Sidecar</a>)</li>
<li>Object Storage (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/store.md" target="_blank" rel="noopener">Store Gateway</a>)</li>
<li>Global alerting/recording rules evaluations (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/rule.md" target="_blank" rel="noopener">Ruler</a>)</li>
<li>Metrics received from Prometheus remote write streams (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/receive.md" target="_blank" rel="noopener">Receiver</a>)</li>
<li>Another Querier (you can stack Queriers on top of each other)</li>
<li>Non-Prometheus systems! <ul>
<li>e.g <a href="https://github.com/thanos-io/thanos/blob/master/docs/integrations.md#opentsdb" target="_blank" rel="noopener">OpenTSDB</a></li>
</ul>
</li>
</ul>
<h3 id="Run-time-deduplication-of-HA-groups"><a href="#Run-time-deduplication-of-HA-groups" class="headerlink" title="Run-time deduplication of HA groups"></a>Run-time deduplication of HA groups</h3><p>Prometheus 是有状态的, 不允许复制其数据库. 这意味着通过运行多个 Prometheus 副本来提高高可用性不是很容易使用. Thanos Querier 从多个副本中提取数据, 并对这些数据进行重复数据删除、填补空白, 而这一切对于消费者是透明的. </p>
<h4 id="Metric-数据查询时的流程"><a href="#Metric-数据查询时的流程" class="headerlink" title="Metric 数据查询时的流程"></a>Metric 数据查询时的流程</h4><p><img src="https://raw.githubusercontent.com/thanos-io/thanos/master/docs/img/querier.svg" alt="查询流程图"></p>
<p>上图展示了 Querier 对每个 Prometheus 查询请求执行的操作. </p>
<p>有关如何将 Querier 与所需的 StoreAPI 连接的信息, 可参见<a href="https://github.com/thanos-io/thanos/blob/master/docs/service-discovery.md" target="_blank" rel="noopener">此处</a>.</p>
<h4 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h4><p>查询层可以对从多个副本收集的 series 进行重复数据删除. 通过为副本设置标签, 然后在启动时将其传递给查询节点来实现.</p>
<h4 id="Query-API"><a href="#Query-API" class="headerlink" title="Query API"></a>Query API</h4><p>Thanos 的 QueryAPI 与 Prometheus 2.x 兼容, 对于 Prometheus 之上的其他功能, Thanos 添加了:</p>
<ul>
<li>部分响应行为(partial response behaviour)</li>
<li>一些额外的参数</li>
<li>自定义响应字段</li>
</ul>
<h4 id="partial-response-behaviour"><a href="#partial-response-behaviour" class="headerlink" title="partial response behaviour"></a>partial response behaviour</h4><p>QueryAPI 和 StoreAPI 通过 PartialResponseStrategy 查询参数来控制准确性和可用性的折中.</p>
<p>在对 QueryAPI 或 StoreAPI 的查询中, 部分响应并不意味着丢失了数据：如果其中一个 StoreAPI 返回错误或超时，而另两个返回成功, 如果损坏的 StoreAPI 没有任何查询内容, 则实际上可以获取正确的数据.</p>
<p>Querier 允许配置不同的超时:</p>
<ul>
<li><code>--query.timeout</code></li>
<li><code>--store.response-timeout</code></li>
</ul>
<p>如果更喜欢可用性而不是准确性, 则可以为底层 StoreAPI 设置比整体查询超时更严格的超时. </p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>通过 Query API 查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// QueryAPI is an API used by Thanos Querier.</span><br><span class="line">type QueryAPI struct &#123;</span><br><span class="line">	baseAPI         *api.BaseAPI</span><br><span class="line">	logger          log.Logger</span><br><span class="line">	gate            gate.Gate</span><br><span class="line">	queryableCreate query.QueryableCreator</span><br><span class="line">	// queryEngine returns appropriate promql.Engine for a query with a given step.</span><br><span class="line">	queryEngine func(int64) *promql.Engine</span><br><span class="line">	ruleGroups  rules.UnaryClient</span><br><span class="line"></span><br><span class="line">	enableAutodownsampling     bool</span><br><span class="line">	enableQueryPartialResponse bool</span><br><span class="line">	enableRulePartialResponse  bool</span><br><span class="line"></span><br><span class="line">	replicaLabels []string</span><br><span class="line">	storeSet      *query.StoreSet</span><br><span class="line"></span><br><span class="line">	defaultInstantQueryMaxSourceResolution time.Duration</span><br><span class="line">	defaultMetadataTimeRange               time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qapi *QueryAPI)</span> <span class="title">queryRange</span><span class="params">(r *http.Request)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, []error, *api.ApiError)</span></span> &#123;</span><br><span class="line">	start, err := parseTime(r.FormValue(<span class="string">"start"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end, err := parseTime(r.FormValue(<span class="string">"end"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> end.Before(start) &#123;</span><br><span class="line">		err := errors.New(<span class="string">"end timestamp must not be before start time"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	step, err := parseDuration(r.FormValue(<span class="string">"step"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: errors.Wrap(err, <span class="string">"param step"</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> step &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		err := errors.New(<span class="string">"zero or negative query resolution step widths are not accepted. Try a positive integer"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For safety, limit the number of returned points per timeseries.</span></span><br><span class="line">	<span class="comment">// This is sufficient for 60s resolution for a week or 1h resolution for a year.</span></span><br><span class="line">	<span class="keyword">if</span> end.Sub(start)/step &gt; <span class="number">11000</span> &#123;</span><br><span class="line">		err := errors.New(<span class="string">"exceeded maximum resolution of 11,000 points per timeseries. Try decreasing the query resolution (?step=XX)"</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := r.Context()</span><br><span class="line">	<span class="keyword">if</span> to := r.FormValue(<span class="string">"timeout"</span>); to != <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> cancel context.CancelFunc</span><br><span class="line">		timeout, err := parseDuration(to)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ctx, cancel = context.WithTimeout(ctx, timeout)</span><br><span class="line">		<span class="keyword">defer</span> cancel()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enableDedup, apiErr := qapi.parseEnableDedupParam(r)</span><br><span class="line">	<span class="keyword">if</span> apiErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	replicaLabels, apiErr := qapi.parseReplicaLabelsParam(r)</span><br><span class="line">	<span class="keyword">if</span> apiErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	storeDebugMatchers, apiErr := qapi.parseStoreDebugMatchersParam(r)</span><br><span class="line">	<span class="keyword">if</span> apiErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no max_source_resolution is specified fit at least 5 samples between steps.</span></span><br><span class="line">	maxSourceResolution, apiErr := qapi.parseDownsamplingParamMillis(r, step/<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">if</span> apiErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enablePartialResponse, apiErr := qapi.parsePartialResponseParam(r, qapi.enableQueryPartialResponse)</span><br><span class="line">	<span class="keyword">if</span> apiErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	qe := qapi.queryEngine(maxSourceResolution)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We are starting promQL tracing span here, because we have no control over promQL code.</span></span><br><span class="line">	span, ctx := tracing.StartSpan(ctx, <span class="string">"promql_range_query"</span>)</span><br><span class="line">	<span class="keyword">defer</span> span.Finish()</span><br><span class="line"></span><br><span class="line">	qry, err := qe.NewRangeQuery(</span><br><span class="line">		qapi.queryableCreate(enableDedup, replicaLabels, storeDebugMatchers, maxSourceResolution, enablePartialResponse, <span class="literal">false</span>),</span><br><span class="line">		r.FormValue(<span class="string">"query"</span>),</span><br><span class="line">		start,</span><br><span class="line">		end,</span><br><span class="line">		step,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tracing.DoInSpan(ctx, <span class="string">"query_gate_ismyturn"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		err = qapi.gate.Start(ctx)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorExec, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> qapi.gate.Done()</span><br><span class="line"></span><br><span class="line">	res := qry.Exec(ctx)</span><br><span class="line">	<span class="keyword">if</span> res.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> res.Err.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> promql.ErrQueryCanceled:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorCanceled, Err: res.Err&#125;</span><br><span class="line">		<span class="keyword">case</span> promql.ErrQueryTimeout:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorTimeout, Err: res.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;api.ApiError&#123;Typ: api.ErrorExec, Err: res.Err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;queryData&#123;</span><br><span class="line">		ResultType: res.Value.Type(),</span><br><span class="line">		Result:     res.Value,</span><br><span class="line">	&#125;, res.Warnings, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解析 time range、step</p>
</li>
<li><p>334 限制每个 time series 最大能返回的数据点数量为 11000 （对于 60s 的分辨率查询一周或者 1h 的分辨率查询一年是足够的）</p>
</li>
<li><p>设置 timeout 如果有的话</p>
</li>
<li><p>根据参数判断是否需要数据去重</p>
</li>
<li><p>根据参数获得副本标签</p>
</li>
<li><p>根据参数解析最大分辨率，默认 step 间至少 5 个点, 控制降采样</p>
</li>
<li><p>根据参数判断是否允许部分响应</p>
</li>
<li><p>根据最大分辨率获得查询引擎</p>
</li>
<li><p>根据上述解析出的几个参数创建 NewRangeQuery 对象</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qry, err := qe.NewRangeQuery(</span><br><span class="line">		qapi.queryableCreate(enableDedup, replicaLabels, storeDebugMatchers, maxSourceResolution, enablePartialResponse, false),</span><br><span class="line">		r.FormValue(&quot;query&quot;),</span><br><span class="line">		start,</span><br><span class="line">		end,</span><br><span class="line">		step,</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>其中, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// QueryableCreator returns implementation of promql.Queryable that fetches data from the proxy store API endpoints.</span><br><span class="line">// If deduplication is enabled, all data retrieved from it will be deduplicated along all replicaLabels by default.</span><br><span class="line">// When the replicaLabels argument is not empty it overwrites the global replicaLabels flag. This allows specifying</span><br><span class="line">// replicaLabels at query time.</span><br><span class="line">// maxResolutionMillis controls downsampling resolution that is allowed (specified in milliseconds).</span><br><span class="line">// partialResponse controls `partialResponseDisabled` option of StoreAPI and partial response behavior of proxy.</span><br><span class="line">type QueryableCreator func(deduplicate bool, replicaLabels []string, storeDebugMatchers [][]*labels.Matcher, maxResolutionMillis int64, partialResponse, skipChunks bool) storage.Queryable</span><br></pre></td></tr></table></figure>

<p>NewRangeQuery 是 Prometheus 的查询引擎：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// NewRangeQuery returns an evaluation query for the given time range and with</span><br><span class="line">// the resolution set by the interval.</span><br><span class="line">func (ng *Engine) NewRangeQuery(q storage.Queryable, qs string, start, end time.Time, interval time.Duration) (Query, error) &#123;</span><br><span class="line">	expr, err := parser.ParseExpr(qs)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	if expr.Type() != parser.ValueTypeVector &amp;&amp; expr.Type() != parser.ValueTypeScalar &#123;</span><br><span class="line">		return nil, errors.Errorf(&quot;invalid expression type %q for range query, must be Scalar or instant Vector&quot;, parser.DocumentedType(expr.Type()))</span><br><span class="line">	&#125;</span><br><span class="line">	qry := ng.newQuery(q, expr, start, end, interval)</span><br><span class="line">	qry.q = qs</span><br><span class="line"></span><br><span class="line">	return qry, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的是一个 Query 结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// A Query is derived from an a raw query string and can be run against an engine</span><br><span class="line">// it is associated with.</span><br><span class="line">type Query interface &#123;</span><br><span class="line">	// Exec processes the query. Can only be called once.</span><br><span class="line">	Exec(ctx context.Context) *Result</span><br><span class="line">	// Close recovers memory used by the query result.</span><br><span class="line">	Close()</span><br><span class="line">	// Statement returns the parsed statement of the query.</span><br><span class="line">	Statement() parser.Statement</span><br><span class="line">	// Stats returns statistics about the lifetime of the query.</span><br><span class="line">	Stats() *stats.QueryTimers</span><br><span class="line">	// Cancel signals that a running query execution should be aborted.</span><br><span class="line">	Cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// matchStore returns true if the given store may hold data for the given label matchers.</span><br><span class="line">func storeMatches(s Client, mint, maxt int64, storeDebugMatchers [][]*labels.Matcher, matchers ...storepb.LabelMatcher) (bool, error) &#123;</span><br><span class="line">	storeMinTime, storeMaxTime := s.TimeRange()</span><br><span class="line">	if mint &gt; storeMaxTime || maxt &lt;= storeMinTime &#123;</span><br><span class="line">		return false, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if !storeMatchDebugMetadata(s, storeDebugMatchers) &#123;</span><br><span class="line">		return false, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	promMatchers, err := storepb.TranslateFromPromMatchers(matchers...)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return false, err</span><br><span class="line">	&#125;</span><br><span class="line">	return labelSetsMatch(promMatchers, s.LabelSets()...), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>Queryable that fetches data from the proxy store API endpoints.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// ProxyStore implements the store API that proxies request to all given underlying stores.</span><br><span class="line">type ProxyStore struct &#123;</span><br><span class="line">	logger         log.Logger</span><br><span class="line">	stores         func() []Client</span><br><span class="line">	component      component.StoreAPI</span><br><span class="line">	selectorLabels labels.Labels</span><br><span class="line"></span><br><span class="line">	responseTimeout time.Duration</span><br><span class="line">	metrics         *proxyStoreMetrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">// Series returns all series for a requested time range and label matcher. Requested series are taken from other</span><br><span class="line">// stores and proxied to RPC client. NOTE: Resulted data are not trimmed exactly to min and max time range.</span><br><span class="line">func (s *ProxyStore) Series(r *storepb.SeriesRequest, srv storepb.Store_SeriesServer) error &#123;</span><br><span class="line">	match, newMatchers, err := matchesExternalLabels(r.Matchers, s.selectorLabels)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return status.Error(codes.InvalidArgument, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	if !match &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if len(newMatchers) == 0 &#123;</span><br><span class="line">		return status.Error(codes.InvalidArgument, errors.New(&quot;no matchers specified (excluding external labels)&quot;).Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g, gctx := errgroup.WithContext(srv.Context())</span><br><span class="line"></span><br><span class="line">	// Allow to buffer max 10 series response.</span><br><span class="line">	// Each might be quite large (multi chunk long series given by sidecar).</span><br><span class="line">	respSender, respCh := newCancelableRespChannel(gctx, 10)</span><br><span class="line"></span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		// This go routine is responsible for calling store&apos;s Series concurrently. Merged results</span><br><span class="line">		// are passed to respCh and sent concurrently to client (if buffer of 10 have room).</span><br><span class="line">		// When this go routine finishes or is canceled, respCh channel is closed.</span><br><span class="line"></span><br><span class="line">		var (</span><br><span class="line">			seriesSet      []storepb.SeriesSet</span><br><span class="line">			storeDebugMsgs []string</span><br><span class="line">			r              = &amp;storepb.SeriesRequest&#123;</span><br><span class="line">				MinTime:                 r.MinTime,</span><br><span class="line">				MaxTime:                 r.MaxTime,</span><br><span class="line">				Matchers:                newMatchers,</span><br><span class="line">				Aggregates:              r.Aggregates,</span><br><span class="line">				MaxResolutionWindow:     r.MaxResolutionWindow,</span><br><span class="line">				SkipChunks:              r.SkipChunks,</span><br><span class="line">				PartialResponseDisabled: r.PartialResponseDisabled,</span><br><span class="line">			&#125;</span><br><span class="line">			wg = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		defer func() &#123;</span><br><span class="line">			wg.Wait()</span><br><span class="line">			close(respCh)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		for _, st := range s.stores() &#123;</span><br><span class="line">			// We might be able to skip the store if its meta information indicates</span><br><span class="line">			// it cannot have series matching our query.</span><br><span class="line">			// NOTE: all matchers are validated in matchesExternalLabels method so we explicitly ignore error.</span><br><span class="line">			var ok bool</span><br><span class="line">			tracing.DoInSpan(gctx, &quot;store_matches&quot;, func(ctx context.Context) &#123;</span><br><span class="line">				var storeDebugMatcher [][]*labels.Matcher</span><br><span class="line">				if ctxVal := srv.Context().Value(StoreMatcherKey); ctxVal != nil &#123;</span><br><span class="line">					if value, ok := ctxVal.([][]*labels.Matcher); ok &#123;</span><br><span class="line">						storeDebugMatcher = value</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				// We can skip error, we already translated matchers once.</span><br><span class="line">				ok, _ = storeMatches(st, r.MinTime, r.MaxTime, storeDebugMatcher, r.Matchers...)</span><br><span class="line">			&#125;)</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				storeDebugMsgs = append(storeDebugMsgs, fmt.Sprintf(&quot;store %s filtered out&quot;, st))</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			storeDebugMsgs = append(storeDebugMsgs, fmt.Sprintf(&quot;Store %s queried&quot;, st))</span><br><span class="line"></span><br><span class="line">			// This is used to cancel this stream when one operations takes too long.</span><br><span class="line">			seriesCtx, closeSeries := context.WithCancel(gctx)</span><br><span class="line">			seriesCtx = grpc_opentracing.ClientAddContextTags(seriesCtx, opentracing.Tags&#123;</span><br><span class="line">				&quot;target&quot;: st.Addr(),</span><br><span class="line">			&#125;)</span><br><span class="line">			defer closeSeries()</span><br><span class="line"></span><br><span class="line">			sc, err := st.Series(seriesCtx, r)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				storeID := labelpb.PromLabelSetsToString(st.LabelSets())</span><br><span class="line">				if storeID == &quot;&quot; &#123;</span><br><span class="line">					storeID = &quot;Store Gateway&quot;</span><br><span class="line">				&#125;</span><br><span class="line">				err = errors.Wrapf(err, &quot;fetch series for %s %s&quot;, storeID, st)</span><br><span class="line">				if r.PartialResponseDisabled &#123;</span><br><span class="line">					level.Error(s.logger).Log(&quot;err&quot;, err, &quot;msg&quot;, &quot;partial response disabled; aborting request&quot;)</span><br><span class="line">					return err</span><br><span class="line">				&#125;</span><br><span class="line">				respSender.send(storepb.NewWarnSeriesResponse(err))</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Schedule streamSeriesSet that translates gRPC streamed response</span><br><span class="line">			// into seriesSet (if series) or respCh if warnings.</span><br><span class="line">			seriesSet = append(seriesSet, startStreamSeriesSet(seriesCtx, s.logger, closeSeries,</span><br><span class="line">				wg, sc, respSender, st.String(), !r.PartialResponseDisabled, s.responseTimeout, s.metrics.emptyStreamResponses))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		level.Debug(s.logger).Log(&quot;msg&quot;, strings.Join(storeDebugMsgs, &quot;;&quot;))</span><br><span class="line">		if len(seriesSet) == 0 &#123;</span><br><span class="line">			// This is indicates that configured StoreAPIs are not the ones end user expects.</span><br><span class="line">			err := errors.New(&quot;No StoreAPIs matched for this query&quot;)</span><br><span class="line">			level.Warn(s.logger).Log(&quot;err&quot;, err, &quot;stores&quot;, strings.Join(storeDebugMsgs, &quot;;&quot;))</span><br><span class="line">			respSender.send(storepb.NewWarnSeriesResponse(err))</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// TODO(bwplotka): Currently we stream into big frames. Consider ensuring 1MB maximum.</span><br><span class="line">		// This however does not matter much when used with QueryAPI. Matters for federated Queries a lot.</span><br><span class="line">		// https://github.com/thanos-io/thanos/issues/2332</span><br><span class="line">		// Series are not necessarily merged across themselves.</span><br><span class="line">		mergedSet := storepb.MergeSeriesSets(seriesSet...)</span><br><span class="line">		for mergedSet.Next() &#123;</span><br><span class="line">			lset, chk := mergedSet.At()</span><br><span class="line">			respSender.send(storepb.NewSeriesResponse(&amp;storepb.Series&#123;Labels: labelpb.ZLabelsFromPromLabels(lset), Chunks: chk&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">		return mergedSet.Err()</span><br><span class="line">	&#125;)</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		// Go routine for gathering merged responses and sending them over to client. It stops when</span><br><span class="line">		// respCh channel is closed OR on error from client.</span><br><span class="line">		for resp := range respCh &#123;</span><br><span class="line">			if err := srv.Send(resp); err != nil &#123;</span><br><span class="line">				return status.Error(codes.Unknown, errors.Wrap(err, &quot;send series response&quot;).Error())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;)</span><br><span class="line">	if err := g.Wait(); err != nil &#123;</span><br><span class="line">		// TODO(bwplotka): Replace with request logger.</span><br><span class="line">		level.Error(s.logger).Log(&quot;err&quot;, err)</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>191, 通过 external 标签匹配 store, 即 pre-filter（filters out external labels matching from matcher if exists as the local storage does not have them.// It also returns false if given matchers are not matching external labels.）</p>
</li>
<li><p>通过 go routine 并发调用各个 store, 等待结果返回</p>
</li>
<li><p>允许最大 10 个 series 结果的 buffer（每个 series 可能很大）， 如果 series 查到数据会先返回给 client</p>
<ul>
<li>遍历各个 store<ul>
<li>先判断 store 是否存有了我们要查询的标签</li>
<li>设置 timeout （This is used to cancel this stream when one operations takes too long.）</li>
<li>接收 series stream</li>
<li>把 response stream 转换成 seriesSet 或者转到 respCh buffer</li>
</ul>
</li>
<li>merge seriesSets</li>
<li>seriesSets 作为结果发给 client</li>
<li>respCh buffer 直接把结果发给 client</li>
</ul>
</li>
</ul>
<p>merge 的操作使用的是 归并排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// MergeSeriesSets takes all series sets and returns as a union single series set.</span><br><span class="line">// It assumes series are sorted by labels within single SeriesSet, similar to remote read guarantees.</span><br><span class="line">// However, they can be partial: in such case, if the single SeriesSet returns the same series within many iterations,</span><br><span class="line">// MergeSeriesSets will merge those into one.</span><br><span class="line">//</span><br><span class="line">// It also assumes in a &quot;best effort&quot; way that chunks are sorted by min time. It&apos;s done as an optimization only, so if input</span><br><span class="line">// series&apos; chunks are NOT sorted, the only consequence is that the duplicates might be not correctly removed. This is double checked</span><br><span class="line">// which on just-before PromQL level as well, so the only consequence is increased network bandwidth.</span><br><span class="line">// If all chunks were sorted, MergeSeriesSet ALSO returns sorted chunks by min time.</span><br><span class="line">//</span><br><span class="line">// Chunks within the same series can also overlap (within all SeriesSet</span><br><span class="line">// as well as single SeriesSet alone). If the chunk ranges overlap, the *exact* chunk duplicates will be removed</span><br><span class="line">// (except one), and any other overlaps will be appended into on chunks slice.</span><br><span class="line">func MergeSeriesSets(all ...SeriesSet) SeriesSet &#123;</span><br><span class="line">	switch len(all) &#123;</span><br><span class="line">	case 0:</span><br><span class="line">		return emptySeriesSet&#123;&#125;</span><br><span class="line">	case 1:</span><br><span class="line">		return newUniqueSeriesSet(all[0])</span><br><span class="line">	&#125;</span><br><span class="line">	h := len(all) / 2</span><br><span class="line"></span><br><span class="line">	return newMergedSeriesSet(</span><br><span class="line">		MergeSeriesSets(all[:h]...),</span><br><span class="line">		MergeSeriesSets(all[h:]...),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func newMergedSeriesSet(a, b SeriesSet) *mergedSeriesSet &#123;</span><br><span class="line">	s := &amp;mergedSeriesSet&#123;a: a, b: b&#125;</span><br><span class="line">	// Initialize first elements of both sets as Next() needs</span><br><span class="line">	// one element look-ahead.</span><br><span class="line">	s.adone = !s.a.Next()</span><br><span class="line">	s.bdone = !s.b.Next()</span><br><span class="line"></span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deduplicate 的操作是遍历去重</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">func newDedupSeriesSet(set storage.SeriesSet, replicaLabels map[string]struct&#123;&#125;, isCounter bool) storage.SeriesSet &#123;</span><br><span class="line">	s := &amp;dedupSeriesSet&#123;set: set, replicaLabels: replicaLabels, isCounter: isCounter&#125;</span><br><span class="line">	s.ok = s.set.Next()</span><br><span class="line">	if s.ok &#123;</span><br><span class="line">		s.peek = s.set.At()</span><br><span class="line">	&#125;</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *dedupSeriesSet) Next() bool &#123;</span><br><span class="line">	if !s.ok &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	// Set the label set we are currently gathering to the peek element</span><br><span class="line">	// without the replica label if it exists.</span><br><span class="line">	s.lset = s.peekLset()</span><br><span class="line">	s.replicas = append(s.replicas[:0], s.peek)</span><br><span class="line">	return s.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// peekLset returns the label set of the current peek element stripped from the</span><br><span class="line">// replica label if it exists.</span><br><span class="line">func (s *dedupSeriesSet) peekLset() labels.Labels &#123;</span><br><span class="line">	lset := s.peek.Labels()</span><br><span class="line">	if len(s.replicaLabels) == 0 &#123;</span><br><span class="line">		return lset</span><br><span class="line">	&#125;</span><br><span class="line">	// Check how many replica labels are present so that these are removed.</span><br><span class="line">	var totalToRemove int</span><br><span class="line">	for i := 0; i &lt; len(s.replicaLabels); i++ &#123;</span><br><span class="line">		if len(lset)-i == 0 &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if _, ok := s.replicaLabels[lset[len(lset)-i-1].Name]; ok &#123;</span><br><span class="line">			totalToRemove++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Strip all present replica labels.</span><br><span class="line">	return lset[:len(lset)-totalToRemove]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *dedupSeriesSet) next() bool &#123;</span><br><span class="line">	// Peek the next series to see whether it&apos;s a replica for the current series.</span><br><span class="line">	s.ok = s.set.Next()</span><br><span class="line">	if !s.ok &#123;</span><br><span class="line">		// There&apos;s no next series, the current replicas are the last element.</span><br><span class="line">		return len(s.replicas) &gt; 0</span><br><span class="line">	&#125;</span><br><span class="line">	s.peek = s.set.At()</span><br><span class="line">	nextLset := s.peekLset()</span><br><span class="line"></span><br><span class="line">	// If the label set modulo the replica label is equal to the current label set</span><br><span class="line">	// look for more replicas, otherwise a series is complete.</span><br><span class="line">	if !labels.Equal(s.lset, nextLset) &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	s.replicas = append(s.replicas, s.peek)</span><br><span class="line">	return s.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *dedupSeriesSet) At() storage.Series &#123;</span><br><span class="line">	if len(s.replicas) == 1 &#123;</span><br><span class="line">		return seriesWithLabels&#123;Series: s.replicas[0], lset: s.lset&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Clients may store the series, so we must make a copy of the slice before advancing.</span><br><span class="line">	repl := make([]storage.Series, len(s.replicas))</span><br><span class="line">	copy(repl, s.replicas)</span><br><span class="line">	return newDedupSeries(s.lset, repl, s.isCounter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a=1, b=2, c=3</p>
<p>a=1, b=2,c=4</p>
<p>a=1, b=2,c=5</p>
<p>a=1, b=3,c=4</p>
<p>a=1, b=3,c=4</p>
<p>a=1, b=6,c=4</p>
</div><div class="tags"><a href="/tags/大监控/">大监控</a></div><div class="post-nav"><a class="pre" href="/2020/11/25/读书笔记/">《Prometheus 云原生监控》读书笔记</a><a class="next" href="/2020/11/22/thanos/">Thanos</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '9068028cdf34808763a3',
  clientSecret: '6a7ac29d31bad8013d5348db4292442adfc4c097',
  repo: 'issues',
  owner: 'huajiaaa',
  admin: ['huajiaaa'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yoursite.com"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/life/">life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/大监控/" style="font-size: 15px;">大监控</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>