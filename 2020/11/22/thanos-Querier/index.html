<!DOCTYPE html><html lang="zh_CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Thanos 的查询过程 | 冰箱里有啤酒和咖啡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Thanos 的查询过程</h1><a id="logo" href="/.">冰箱里有啤酒和咖啡</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Thanos 的查询过程</h1><div class="post-meta">Nov 22, 2020<span> | </span><span class="category"><a href="/categories/技术/">技术</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#流程概览"><span class="toc-number">1.</span> <span class="toc-text">流程概览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#具体步骤"><span class="toc-number">2.</span> <span class="toc-text">具体步骤</span></a></li></ol></div></div><div class="post-content"><p>Thanos 提供了所有 prometheus 的全局查询视角, 可以在查询时删除重复数据和合并 time series, 本文来介绍对 thanos 发起一个查询时发生了什么.</p>
<a id="more"></a>

<h1 id="流程概览"><a href="#流程概览" class="headerlink" title="流程概览"></a>流程概览</h1><img src="https://raw.githubusercontent.com/thanos-io/thanos/master/docs/img/querier.svg" height="30%" width="30%">

<p>如上图所示,</p>
<ol>
<li>Grafana 调用 Thanos 的 Query API, 传入一个 PromQL 查询请求</li>
<li>根据 PromQL 中的标签值对所有的 Store 先做一次预过滤, 即把「没有存储目标数据的 store」过滤出去</li>
<li>分别查询经过上述过滤后的所有 store</li>
<li>合并查询数据</li>
<li>删除冗余数据,返回结果</li>
</ol>
<p>其中, 对于 Querier 而言，Store 是实现了 gRPC StoreAPI 的所有组件，因此我们可以从任意数量的不同存储中聚合数据，例如:</p>
<ul>
<li>Prometheus (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/sidecar.md" target="_blank" rel="noopener">Sidecar</a>)</li>
<li>Object Storage (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/store.md" target="_blank" rel="noopener">Store Gateway</a>)</li>
<li>Global alerting/recording rules evaluations (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/rule.md" target="_blank" rel="noopener">Ruler</a>)</li>
<li>Metrics received from Prometheus remote write streams (see <a href="https://github.com/thanos-io/thanos/blob/master/docs/components/receive.md" target="_blank" rel="noopener">Receiver</a>)</li>
<li>Another Querier (you can stack Queriers on top of each other)</li>
<li>Non-Prometheus systems!<ul>
<li>e.g <a href="https://github.com/thanos-io/thanos/blob/master/docs/integrations.md#opentsdb" target="_blank" rel="noopener">OpenTSDB</a></li>
</ul>
</li>
</ul>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>调用 QueryAPI, 查询数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">func (qapi *QueryAPI) queryRange(r *http.Request) (interface&#123;&#125;, []error, *api.ApiError) &#123;</span><br><span class="line">	start, err := parseTime(r.FormValue(&quot;start&quot;))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end, err := parseTime(r.FormValue(&quot;end&quot;))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if end.Before(start) &#123;</span><br><span class="line">		err := errors.New(&quot;end timestamp must not be before start time&quot;)</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	step, err := parseDuration(r.FormValue(&quot;step&quot;))</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: errors.Wrap(err, &quot;param step&quot;)&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if step &lt;= 0 &#123;</span><br><span class="line">		err := errors.New(&quot;zero or negative query resolution step widths are not accepted. Try a positive integer&quot;)</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// For safety, limit the number of returned points per timeseries.</span><br><span class="line">	// This is sufficient for 60s resolution for a week or 1h resolution for a year.</span><br><span class="line">	if end.Sub(start)/step &gt; 11000 &#123;</span><br><span class="line">		err := errors.New(&quot;exceeded maximum resolution of 11,000 points per timeseries. Try decreasing the query resolution (?step=XX)&quot;)</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := r.Context()</span><br><span class="line">	if to := r.FormValue(&quot;timeout&quot;); to != &quot;&quot; &#123;</span><br><span class="line">		var cancel context.CancelFunc</span><br><span class="line">		timeout, err := parseDuration(to)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ctx, cancel = context.WithTimeout(ctx, timeout)</span><br><span class="line">		defer cancel()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enableDedup, apiErr := qapi.parseEnableDedupParam(r)</span><br><span class="line">	if apiErr != nil &#123;</span><br><span class="line">		return nil, nil, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	replicaLabels, apiErr := qapi.parseReplicaLabelsParam(r)</span><br><span class="line">	if apiErr != nil &#123;</span><br><span class="line">		return nil, nil, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	storeDebugMatchers, apiErr := qapi.parseStoreDebugMatchersParam(r)</span><br><span class="line">	if apiErr != nil &#123;</span><br><span class="line">		return nil, nil, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// If no max_source_resolution is specified fit at least 5 samples between steps.</span><br><span class="line">	maxSourceResolution, apiErr := qapi.parseDownsamplingParamMillis(r, step/5)</span><br><span class="line">	if apiErr != nil &#123;</span><br><span class="line">		return nil, nil, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	enablePartialResponse, apiErr := qapi.parsePartialResponseParam(r, qapi.enableQueryPartialResponse)</span><br><span class="line">	if apiErr != nil &#123;</span><br><span class="line">		return nil, nil, apiErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	qe := qapi.queryEngine(maxSourceResolution)</span><br><span class="line"></span><br><span class="line">	// We are starting promQL tracing span here, because we have no control over promQL code.</span><br><span class="line">	span, ctx := tracing.StartSpan(ctx, &quot;promql_range_query&quot;)</span><br><span class="line">	defer span.Finish()</span><br><span class="line"></span><br><span class="line">	qry, err := qe.NewRangeQuery(</span><br><span class="line">		qapi.queryableCreate(enableDedup, replicaLabels, storeDebugMatchers, maxSourceResolution, enablePartialResponse, false),</span><br><span class="line">		r.FormValue(&quot;query&quot;),</span><br><span class="line">		start,</span><br><span class="line">		end,</span><br><span class="line">		step,</span><br><span class="line">	)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorBadData, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tracing.DoInSpan(ctx, &quot;query_gate_ismyturn&quot;, func(ctx context.Context) &#123;</span><br><span class="line">		err = qapi.gate.Start(ctx)</span><br><span class="line">	&#125;)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorExec, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	defer qapi.gate.Done()</span><br><span class="line"></span><br><span class="line">	res := qry.Exec(ctx)                    //关键, 在这个方法中实现了 pre-filter、fanout、merge、Deduplicate</span><br><span class="line">	if res.Err != nil &#123;</span><br><span class="line">		switch res.Err.(type) &#123;</span><br><span class="line">		case promql.ErrQueryCanceled:</span><br><span class="line">			return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorCanceled, Err: res.Err&#125;</span><br><span class="line">		case promql.ErrQueryTimeout:</span><br><span class="line">			return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorTimeout, Err: res.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return nil, nil, &amp;api.ApiError&#123;Typ: api.ErrorExec, Err: res.Err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return &amp;queryData&#123;</span><br><span class="line">		ResultType: res.Value.Type(),</span><br><span class="line">		Result:     res.Value,</span><br><span class="line">	&#125;, res.Warnings, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析 time range、step</li>
<li>限制每个 time series 最大能返回的数据点数（ 11000  对于 60s 的分辨率查询一周或者 1h 的分辨率查询一年是足够的）</li>
<li>设置 timeout（如果有的话）</li>
<li>根据参数判断是否需要数据去重</li>
<li>根据参数获得副本标签</li>
<li>根据参数解析最大分辨率，默认 step 间至少 5 个点, 控制降采样</li>
<li>根据参数判断是否允许部分响应</li>
<li>根据最大分辨率获得查询引擎 (returns appropriate promql.Engine for a query with a given step.)</li>
<li>根据上述解析出的几个参数创建 NewRangeQuery 对象</li>
<li>调用 Exec 方法查询数据</li>
</ul>
<p>其中,  newRangeQuery 是 prometheus 的查询引擎.</p>
<p>通过 QueryableCreator 创建了一个 Queryable， QueryableCreator 方法如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// QueryableCreator returns implementation of promql. that fetches data from the proxy store API endpoints.</span><br><span class="line">// If deduplication is enabled, all data retrieved from it will be deduplicated along all replicaLabels by default.</span><br><span class="line">// When the replicaLabels argument is not empty it overwrites the global replicaLabels flag. This allows specifying</span><br><span class="line">// replicaLabels at query time.</span><br><span class="line">// maxResolutionMillis controls downsampling resolution that is allowed (specified in milliseconds).</span><br><span class="line">// partialResponse controls `partialResponseDisabled` option of StoreAPI and partial response behavior of proxy.</span><br><span class="line">type QueryableCreator func(deduplicate bool, replicaLabels []string, storeDebugMatchers [][]*labels.Matcher, maxResolutionMillis int64, partialResponse, skipChunks bool) storage.Queryable</span><br></pre></td></tr></table></figure>

<p>根据注释可以看出, Thanos 使用的是 proxy store 进行查询.</p>
<p>在 402 行调用 Exec 方法进行数据查询. 其中, Exec 中会调用 queryable 的 select 方法.</p>
<p>当调用 select 方法时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">func (q *querier) Select(_ bool, hints *storage.SelectHints, ms ...*labels.Matcher) storage.SeriesSet &#123;</span><br><span class="line">   if hints == nil &#123;</span><br><span class="line">      hints = &amp;storage.SelectHints&#123;</span><br><span class="line">         Start: q.mint,</span><br><span class="line">         End:   q.maxt,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   matchers := make([]string, len(ms))</span><br><span class="line">   for i, m := range ms &#123;</span><br><span class="line">      matchers[i] = m.String()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // The querier has a context but it gets canceled, as soon as query evaluation is completed, by the engine.</span><br><span class="line">   // We want to prevent this from happening for the async storea API calls we make while preserving tracing context.</span><br><span class="line">   ctx := tracing.CopyTraceContext(context.Background(), q.ctx)</span><br><span class="line">   ctx, cancel := context.WithTimeout(ctx, q.selectTimeout)</span><br><span class="line">   span, ctx := tracing.StartSpan(ctx, &quot;querier_select&quot;, opentracing.Tags&#123;</span><br><span class="line">      &quot;minTime&quot;:  hints.Start,</span><br><span class="line">      &quot;maxTime&quot;:  hints.End,</span><br><span class="line">      &quot;matchers&quot;: &quot;&#123;&quot; + strings.Join(matchers, &quot;,&quot;) + &quot;&#125;&quot;,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   promise := make(chan storage.SeriesSet, 1)</span><br><span class="line">   go func() &#123;</span><br><span class="line">      defer close(promise)</span><br><span class="line"></span><br><span class="line">      var err error</span><br><span class="line">      tracing.DoInSpan(ctx, &quot;querier_select_gate_ismyturn&quot;, func(ctx context.Context) &#123;</span><br><span class="line">         err = q.selectGate.Start(ctx)</span><br><span class="line">      &#125;)</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         promise &lt;- storage.ErrSeriesSet(errors.Wrap(err, &quot;failed to wait for turn&quot;))</span><br><span class="line">         return</span><br><span class="line">      &#125;</span><br><span class="line">      defer q.selectGate.Done()</span><br><span class="line"></span><br><span class="line">      span, ctx := tracing.StartSpan(ctx, &quot;querier_select_select_fn&quot;)</span><br><span class="line">      defer span.Finish()</span><br><span class="line"></span><br><span class="line">      set, err := q.selectFn(ctx, hints, ms...)</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         promise &lt;- storage.ErrSeriesSet(err)</span><br><span class="line">         return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      promise &lt;- set</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   return &amp;lazySeriesSet&#123;create: func() (storage.SeriesSet, bool) &#123;</span><br><span class="line">      defer cancel()</span><br><span class="line">      defer span.Finish()</span><br><span class="line"></span><br><span class="line">      // Only gets called once, for the first Next() call of the series set.</span><br><span class="line">      set, ok := &lt;-promise</span><br><span class="line">      if !ok &#123;</span><br><span class="line">         return storage.ErrSeriesSet(errors.New(&quot;channel closed before a value received&quot;)), false</span><br><span class="line">      &#125;</span><br><span class="line">      return set, set.Next()</span><br><span class="line">   &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了一些 tracing 记录外, 核心是调用了 selectFn 方法,  <strong>在这个方法里实现了  pre-filter、Fanout、Merge、deduplicate</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">func (q *querier) selectFn(ctx context.Context, hints *storage.SelectHints, ms ...*labels.Matcher) (storage.SeriesSet, error) &#123;</span><br><span class="line">   sms, err := storepb.TranslatePromMatchers(ms...)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return nil, errors.Wrap(err, &quot;convert matchers&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   aggrs := aggrsFromFunc(hints.Func)</span><br><span class="line"></span><br><span class="line">   // TODO(bwplotka): Pass it using the SeriesRequest instead of relying on context.</span><br><span class="line">   ctx = context.WithValue(ctx, store.StoreMatcherKey, q.storeDebugMatchers)</span><br><span class="line"></span><br><span class="line">   resp := &amp;seriesServer&#123;ctx: ctx&#125;</span><br><span class="line">   if err := q.proxy.Series(&amp;storepb.SeriesRequest&#123;                            //实现了 pre-filter、fanout、merge</span><br><span class="line">      MinTime:                 hints.Start,</span><br><span class="line">      MaxTime:                 hints.End,</span><br><span class="line">      Matchers:                sms,</span><br><span class="line">      MaxResolutionWindow:     q.maxResolutionMillis,</span><br><span class="line">      Aggregates:              aggrs,</span><br><span class="line">      PartialResponseDisabled: !q.partialResponse,</span><br><span class="line">      SkipChunks:              q.skipChunks,</span><br><span class="line">   &#125;, resp); err != nil &#123;</span><br><span class="line">      return nil, errors.Wrap(err, &quot;proxy Series()&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   var warns storage.Warnings</span><br><span class="line">   for _, w := range resp.warnings &#123;</span><br><span class="line">      warns = append(warns, errors.New(w))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if !q.isDedupEnabled() &#123;</span><br><span class="line">      // Return data without any deduplication.</span><br><span class="line">      return &amp;promSeriesSet&#123;</span><br><span class="line">         mint:  q.mint,</span><br><span class="line">         maxt:  q.maxt,</span><br><span class="line">         set:   newStoreSeriesSet(resp.seriesSet),</span><br><span class="line">         aggrs: aggrs,</span><br><span class="line">         warns: warns,</span><br><span class="line">      &#125;, nil</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // TODO(fabxc): this could potentially pushed further down into the store API to make true streaming possible.</span><br><span class="line">   sortDedupLabels(resp.seriesSet, q.replicaLabels)</span><br><span class="line">   set := &amp;promSeriesSet&#123;</span><br><span class="line">      mint:  q.mint,</span><br><span class="line">      maxt:  q.maxt,</span><br><span class="line">      set:   newStoreSeriesSet(resp.seriesSet),</span><br><span class="line">      aggrs: aggrs,</span><br><span class="line">      warns: warns,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // The merged series set assembles all potentially-overlapping time ranges of the same series into a single one.</span><br><span class="line">   // TODO(bwplotka): We could potentially dedup on chunk level, use chunk iterator for that when available.</span><br><span class="line">   return newDedupSeriesSet(set, q.replicaLabels, len(aggrs) == 1 &amp;&amp; aggrs[0] == storepb.Aggr_COUNTER), nil    // 实现了 deduplicate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用 Series 方法获得所有的 series 数据, 在这个方法里实现了  pre-filter、Fanout、Merge</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">// Series returns all series for a requested time range and label matcher. Requested series are taken from other</span><br><span class="line">// stores and proxied to RPC client. NOTE: Resulted data are not trimmed exactly to min and max time range.</span><br><span class="line">func (s *ProxyStore) Series(r *storepb.SeriesRequest, srv storepb.Store_SeriesServer) error &#123;</span><br><span class="line">	match, newMatchers, err := matchesExternalLabels(r.Matchers, s.selectorLabels)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return status.Error(codes.InvalidArgument, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	if !match &#123;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if len(newMatchers) == 0 &#123;</span><br><span class="line">		return status.Error(codes.InvalidArgument, errors.New(&quot;no matchers specified (excluding external labels)&quot;).Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g, gctx := errgroup.WithContext(srv.Context())</span><br><span class="line"></span><br><span class="line">	// Allow to buffer max 10 series response.</span><br><span class="line">	// Each might be quite large (multi chunk long series given by sidecar).</span><br><span class="line">	respSender, respCh := newCancelableRespChannel(gctx, 10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	// 生产者协程</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		// This go routine is responsible for calling store&apos;s Series concurrently. Merged results</span><br><span class="line">		// are passed to respCh and sent concurrently to client (if buffer of 10 have room).</span><br><span class="line">		// When this go routine finishes or is canceled, respCh channel is closed.</span><br><span class="line"></span><br><span class="line">		var (</span><br><span class="line">			seriesSet      []storepb.SeriesSet</span><br><span class="line">			storeDebugMsgs []string</span><br><span class="line">			r              = &amp;storepb.SeriesRequest&#123;</span><br><span class="line">				MinTime:                 r.MinTime,</span><br><span class="line">				MaxTime:                 r.MaxTime,</span><br><span class="line">				Matchers:                newMatchers,</span><br><span class="line">				Aggregates:              r.Aggregates,</span><br><span class="line">				MaxResolutionWindow:     r.MaxResolutionWindow,</span><br><span class="line">				SkipChunks:              r.SkipChunks,</span><br><span class="line">				PartialResponseDisabled: r.PartialResponseDisabled,</span><br><span class="line">			&#125;</span><br><span class="line">			wg = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">		defer func() &#123;</span><br><span class="line">			wg.Wait()</span><br><span class="line">			close(respCh)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		for _, st := range s.stores() &#123;</span><br><span class="line">			// We might be able to skip the store if its meta information indicates</span><br><span class="line">			// it cannot have series matching our query.</span><br><span class="line">			// NOTE: all matchers are validated in matchesExternalLabels method so we explicitly ignore error.</span><br><span class="line">			var ok bool</span><br><span class="line">			tracing.DoInSpan(gctx, &quot;store_matches&quot;, func(ctx context.Context) &#123;</span><br><span class="line">				var storeDebugMatcher [][]*labels.Matcher</span><br><span class="line">				if ctxVal := srv.Context().Value(StoreMatcherKey); ctxVal != nil &#123;</span><br><span class="line">					if value, ok := ctxVal.([][]*labels.Matcher); ok &#123;</span><br><span class="line">						storeDebugMatcher = value</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				// We can skip error, we already translated matchers once.</span><br><span class="line">				ok, _ = storeMatches(st, r.MinTime, r.MaxTime, storeDebugMatcher, r.Matchers...)</span><br><span class="line">			&#125;)</span><br><span class="line">			if !ok &#123;</span><br><span class="line">				storeDebugMsgs = append(storeDebugMsgs, fmt.Sprintf(&quot;store %s filtered out&quot;, st))</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">			storeDebugMsgs = append(storeDebugMsgs, fmt.Sprintf(&quot;Store %s queried&quot;, st))</span><br><span class="line"></span><br><span class="line">			// This is used to cancel this stream when one operations takes too long.</span><br><span class="line">			seriesCtx, closeSeries := context.WithCancel(gctx)</span><br><span class="line">			seriesCtx = grpc_opentracing.ClientAddContextTags(seriesCtx, opentracing.Tags&#123;</span><br><span class="line">				&quot;target&quot;: st.Addr(),</span><br><span class="line">			&#125;)</span><br><span class="line">			defer closeSeries()</span><br><span class="line"></span><br><span class="line">			sc, err := st.Series(seriesCtx, r)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				storeID := labelpb.PromLabelSetsToString(st.LabelSets())</span><br><span class="line">				if storeID == &quot;&quot; &#123;</span><br><span class="line">					storeID = &quot;Store Gateway&quot;</span><br><span class="line">				&#125;</span><br><span class="line">				err = errors.Wrapf(err, &quot;fetch series for %s %s&quot;, storeID, st)</span><br><span class="line">				if r.PartialResponseDisabled &#123;</span><br><span class="line">					level.Error(s.logger).Log(&quot;err&quot;, err, &quot;msg&quot;, &quot;partial response disabled; aborting request&quot;)</span><br><span class="line">					return err</span><br><span class="line">				&#125;</span><br><span class="line">				respSender.send(storepb.NewWarnSeriesResponse(err))</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Schedule streamSeriesSet that translates gRPC streamed response</span><br><span class="line">			// into seriesSet (if series) or respCh if warnings.</span><br><span class="line">			seriesSet = append(seriesSet, startStreamSeriesSet(seriesCtx, s.logger, closeSeries,</span><br><span class="line">				wg, sc, respSender, st.String(), !r.PartialResponseDisabled, s.responseTimeout, s.metrics.emptyStreamResponses))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		level.Debug(s.logger).Log(&quot;msg&quot;, strings.Join(storeDebugMsgs, &quot;;&quot;))</span><br><span class="line">		if len(seriesSet) == 0 &#123;</span><br><span class="line">			// This is indicates that configured StoreAPIs are not the ones end user expects.</span><br><span class="line">			err := errors.New(&quot;No StoreAPIs matched for this query&quot;)</span><br><span class="line">			level.Warn(s.logger).Log(&quot;err&quot;, err, &quot;stores&quot;, strings.Join(storeDebugMsgs, &quot;;&quot;))</span><br><span class="line">			respSender.send(storepb.NewWarnSeriesResponse(err))</span><br><span class="line">			return nil</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// TODO(bwplotka): Currently we stream into big frames. Consider ensuring 1MB maximum.</span><br><span class="line">		// This however does not matter much when used with QueryAPI. Matters for federated Queries a lot.</span><br><span class="line">		// https://github.com/thanos-io/thanos/issues/2332</span><br><span class="line">		// Series are not necessarily merged across themselves.</span><br><span class="line">		mergedSet := storepb.MergeSeriesSets(seriesSet...) //使用的是归并排序, ps: 这个 TODO 有人跑了个 benchmark, 最终认为不那么可行或必要</span><br><span class="line">		for mergedSet.Next() &#123;</span><br><span class="line">			lset, chk := mergedSet.At()</span><br><span class="line">			respSender.send(storepb.NewSeriesResponse(&amp;storepb.Series&#123;Labels: labelpb.ZLabelsFromPromLabels(lset), Chunks: chk&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">		return mergedSet.Err()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	// 消费者协程</span><br><span class="line">	g.Go(func() error &#123;</span><br><span class="line">		// Go routine for gathering merged responses and sending them over to client. It stops when</span><br><span class="line">		// respCh channel is closed OR on error from client.</span><br><span class="line">		for resp := range respCh &#123;</span><br><span class="line">			if err := srv.Send(resp); err != nil &#123;</span><br><span class="line">				return status.Error(codes.Unknown, errors.Wrap(err, &quot;send series response&quot;).Error())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return nil</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	// 等待生产者协程和消费者协程结束</span><br><span class="line">	if err := g.Wait(); err != nil &#123;</span><br><span class="line">		// TODO(bwplotka): Replace with request logger.</span><br><span class="line">		level.Error(s.logger).Log(&quot;err&quot;, err)</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// MergeSeriesSets takes all series sets and returns as a union single series set.</span><br><span class="line">// It assumes series are sorted by labels within single SeriesSet, similar to remote read guarantees.</span><br><span class="line">// However, they can be partial: in such case, if the single SeriesSet returns the same series within many iterations,</span><br><span class="line">// MergeSeriesSets will merge those into one.</span><br><span class="line">//</span><br><span class="line">// It also assumes in a &quot;best effort&quot; way that chunks are sorted by min time. It&apos;s done as an optimization only, so if input</span><br><span class="line">// series&apos; chunks are NOT sorted, the only consequence is that the duplicates might be not correctly removed. This is double checked</span><br><span class="line">// which on just-before PromQL level as well, so the only consequence is increased network bandwidth.</span><br><span class="line">// If all chunks were sorted, MergeSeriesSet ALSO returns sorted chunks by min time.</span><br><span class="line">//</span><br><span class="line">// Chunks within the same series can also overlap (within all SeriesSet</span><br><span class="line">// as well as single SeriesSet alone). If the chunk ranges overlap, the *exact* chunk duplicates will be removed</span><br><span class="line">// (except one), and any other overlaps will be appended into on chunks slice.</span><br><span class="line">func MergeSeriesSets(all ...SeriesSet) SeriesSet &#123;</span><br><span class="line">	switch len(all) &#123;</span><br><span class="line">	case 0:</span><br><span class="line">		return emptySeriesSet&#123;&#125;</span><br><span class="line">	case 1:</span><br><span class="line">		return newUniqueSeriesSet(all[0])</span><br><span class="line">	&#125;</span><br><span class="line">	h := len(all) / 2</span><br><span class="line"></span><br><span class="line">	return newMergedSeriesSet(</span><br><span class="line">		MergeSeriesSets(all[:h]...),</span><br><span class="line">		MergeSeriesSets(all[h:]...),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">func newDedupSeriesSet(set storage.SeriesSet, replicaLabels map[string]struct&#123;&#125;, isCounter bool) storage.SeriesSet &#123;</span><br><span class="line">	s := &amp;dedupSeriesSet&#123;set: set, replicaLabels: replicaLabels, isCounter: isCounter&#125;</span><br><span class="line">	s.ok = s.set.Next()</span><br><span class="line">	if s.ok &#123;</span><br><span class="line">		s.peek = s.set.At()</span><br><span class="line">	&#125;</span><br><span class="line">	return s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *dedupSeriesSet) Next() bool &#123;</span><br><span class="line">	if !s.ok &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	// Set the label set we are currently gathering to the peek element</span><br><span class="line">	// without the replica label if it exists.</span><br><span class="line">	s.lset = s.peekLset()</span><br><span class="line">	s.replicas = append(s.replicas[:0], s.peek)</span><br><span class="line">	return s.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// peekLset returns the label set of the current peek element stripped from the</span><br><span class="line">// replica label if it exists.</span><br><span class="line">func (s *dedupSeriesSet) peekLset() labels.Labels &#123;</span><br><span class="line">	lset := s.peek.Labels()</span><br><span class="line">	if len(s.replicaLabels) == 0 &#123;</span><br><span class="line">		return lset</span><br><span class="line">	&#125;</span><br><span class="line">	// Check how many replica labels are present so that these are removed.</span><br><span class="line">	var totalToRemove int</span><br><span class="line">	for i := 0; i &lt; len(s.replicaLabels); i++ &#123;</span><br><span class="line">		if len(lset)-i == 0 &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if _, ok := s.replicaLabels[lset[len(lset)-i-1].Name]; ok &#123;</span><br><span class="line">			totalToRemove++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Strip all present replica labels.</span><br><span class="line">	return lset[:len(lset)-totalToRemove]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *dedupSeriesSet) next() bool &#123;</span><br><span class="line">	// Peek the next series to see whether it&apos;s a replica for the current series.</span><br><span class="line">	s.ok = s.set.Next()</span><br><span class="line">	if !s.ok &#123;</span><br><span class="line">		// There&apos;s no next series, the current replicas are the last element.</span><br><span class="line">		return len(s.replicas) &gt; 0</span><br><span class="line">	&#125;</span><br><span class="line">	s.peek = s.set.At()</span><br><span class="line">	nextLset := s.peekLset()</span><br><span class="line"></span><br><span class="line">	// If the label set modulo the replica label is equal to the current label set</span><br><span class="line">	// look for more replicas, otherwise a series is complete.</span><br><span class="line">	if !labels.Equal(s.lset, nextLset) &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	s.replicas = append(s.replicas, s.peek)</span><br><span class="line">	return s.next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *dedupSeriesSet) At() storage.Series &#123;</span><br><span class="line">	if len(s.replicas) == 1 &#123;</span><br><span class="line">		return seriesWithLabels&#123;Series: s.replicas[0], lset: s.lset&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// Clients may store the series, so we must make a copy of the slice before advancing.</span><br><span class="line">	repl := make([]storage.Series, len(s.replicas))</span><br><span class="line">	copy(repl, s.replicas)</span><br><span class="line">	return newDedupSeries(s.lset, repl, s.isCounter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select 方法总结: </p>
<ul>
<li>通过 externalLabels 匹配 store, 即流程图中的 pre-filter（filters out external labels matching from matcher if exists as the local storage does not have them.// It also returns false if given matchers are not matching external labels.）<ul>
<li>其中, external labels 即为 <a href="https://confluence.zhenguanyu.com/pages/viewpage.action?pageId=106625145#Thanos学习-Stores" target="_blank" rel="noopener">Thanos 学习#Stores</a> 中提到的额外元信息</li>
</ul>
</li>
<li>允许最大 10 个 series 结果的 buffer， 如果 series 查到数据会先返回给 client<ul>
<li>遍历各个 store, 通过 go routine 并发执行下述操作： <ul>
<li>先判断 store 是否存有了我们要查询的标签</li>
<li>设置 timeout （This is used to cancel this stream when one operations takes too long.）</li>
<li>向 store 查询数据, 并接收 response stream</li>
<li>把 response stream 转换成 seriesSet 或者转到 respCh buffer<ul>
<li>respCh buffer 直接把结果发给 client</li>
</ul>
</li>
</ul>
</li>
<li>merge seriesSets, 使用的是归并排序, 把同一个 series 的多段按照时间顺序合并成一个（多段是因为从不同的 block 中取出, 可参考 <a href="https://confluence.zhenguanyu.com/display/COL/tsdb#tsdb-样本点的生命周期" target="_blank" rel="noopener">tsdb</a>)</li>
<li>seriesSets 作为结果发给 client, 即 Querier</li>
</ul>
</li>
<li>Querier 根据查询参数判断直接把 seriesSet 结果返回, 或是做去重操作<ul>
<li>去重操作的实现是: 遍历所有 series, 去掉每个 series 中包含的特定 replicaLabel(比如多副本时, 每个副本都有一个自己的标签); 如果去掉特殊标签后的多个 series 的标签对是一样的, 即认为是重复的, 去掉只留其一</li>
</ul>
</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Author: </strong>huajiaaa</li><li class="post-copyright-link"><strong>Blog Link: </strong><a href="/2020/11/22/thanos-Querier/">http://yoursite.com/2020/11/22/thanos-Querier/</a></li><li class="post-copyright-license"><strong>Copyright Declaration: </strong>本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 CN 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="/tags/大监控/">大监控</a><a href="/tags/thanos/">thanos</a></div><div class="post-nav"><a class="pre" href="/2020/11/25/读书笔记/">《Prometheus 云原生监控》读书笔记</a><a class="next" href="/2020/11/22/thanos/">Thanos</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '9068028cdf34808763a3',
  clientSecret: '6a7ac29d31bad8013d5348db4292442adfc4c097',
  repo: 'issues',
  owner: 'huajiaaa',
  admin: ['huajiaaa'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yoursite.com"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/大监控/" style="font-size: 15px;">大监控</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a> <a href="/tags/thanos/" style="font-size: 15px;">thanos</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>