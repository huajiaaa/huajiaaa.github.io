<!DOCTYPE html><html lang="zh_CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Weekly Leetcode &quot;Pick One&quot; | 冰箱里有啤酒和咖啡</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Weekly Leetcode &quot;Pick One&quot;</h1><a id="logo" href="/.">冰箱里有啤酒和咖啡</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Weekly Leetcode &quot;Pick One&quot;</h1><div class="post-meta">Nov 28, 2020<span> | </span><span class="category"><a href="/categories/算法/">算法</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Inhalte</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1"><span class="toc-number">1.</span> <span class="toc-text">week 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-1"><span class="toc-number">1.1.</span> <span class="toc-text">Problem 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过程"><span class="toc-number">1.1.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结果"><span class="toc-number">1.1.2.</span> <span class="toc-text">结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-2"><span class="toc-number">1.2.</span> <span class="toc-text">Problem 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#过程-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">过程</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>每周<strong>至少一道</strong> LeetCode “随机一题”, 就这样.</p>
<h1 id="week-1"><a href="#week-1" class="headerlink" title="week 1"></a>week 1</h1><h2 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h2><p><a href="https://leetcode.com/problems/stone-game/" target="_blank" rel="noopener">877. stone-game</a></p>
<p>Alex and Lee play a game with piles of stones.  There are an even number of piles <strong>arranged in a row</strong>, and each pile has a positive integer number of stones <code>piles[i]</code>.</p>
<p>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.</p>
<p>Alex and Lee take turns, with Alex starting first.  Each turn, a  player takes the entire pile of stones from either the beginning or the  end of the row.  This continues until there are no more piles left, at  which point the person with the most stones wins.</p>
<p>Assuming Alex and Lee play optimally, return <code>True</code> if and only if Alex wins the game.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [5,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">Alex starts first, and can only take the first 5 or the last 5.</span><br><span class="line">Say he takes the first 5, so that the row becomes [3, 4, 5].</span><br><span class="line">If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.</span><br><span class="line">If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.</span><br><span class="line">This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</span><br></pre></td></tr></table></figure>

<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= piles.length &lt;= 500</code></li>
<li><code>piles.length</code> is even.</li>
<li><code>1 &lt;= piles[i] &lt;= 500</code></li>
<li><code>sum(piles)</code> is odd.</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>题目比较容易理解: 一个数组, 两个老哥轮流从数组的头或者尾取数字, 假设俩老哥都聪绝顶, 问先手的老哥能赢吗？</p>
<p>看到题目最先想到能不能抽象出一个方法, 变成递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// i,j 表示当前的下标, point 表示先手老哥的分数(可以为负数)</span><br><span class="line">public boolean helper(int[] piles, int i, int j, int point) &#123;</span><br><span class="line">	if( i == j) &#123;//递归退出条件</span><br><span class="line">		return piles[i] &lt; point; // 用小于号, 因为最后一个拿数字的是后手老哥</span><br><span class="line">	&#125;</span><br><span class="line">	int multiplier = (j - i) % 2 == 1 ？ 1 ：-1； //判断此次是哪个老哥拿数字, 先手老哥是加, 后手老哥是减</span><br><span class="line">	return helper(piles, i + 1, j, point + piles[i] * multiplier) || helper(piles, i, j - 1, point + piless[j] * multiplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概就是上述代码的思路, 但是我没有去运行, 因为感觉上会爆炸, 需要剪枝; 因为显然很多计算会是重复的.</p>
<p>之后想还是用动态规划来做吧, 于是开始找规律, 感觉上应该是二维的 dp, 即 dp[i][j].</p>
<p>自己列了一个 case: [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
<p>最后找到规律是: dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[j][j - 1])</p>
<p>其中, dp[i][j] 代表先手老哥在从 piles[i] ~ piles[j] 这段数字中取数字时, 最多比后手老哥多取多少个数.</p>
<p>之后是实现了:</p>
<p>这个 dp 不像是常规的 dp, 算是有个坑吧, 因为不能像常规的那种 dp 题目, 两个 for 循环从 0 到 len 填充 dp[i][j].</p>
<p>因为这个 dp 推导式的特殊性, 正常 for 循环会发现当计算 dp[i][j] 时 所需要的 dp[i + 1][j] 还没有被算到…</p>
<p>最终依然通过找规律吧, 发现可以通过 step 的方式填充 dp, 即 dp[i][i] 是直接能知道的, dp[i][i + 1] 在知道 dp[i][i] 的前提下也能知道. 因此, 按照:</p>
<p>dp 00、 11、 22 ….</p>
<p>dp 01、12、 23 …</p>
<p>dp 02、 13、 24…</p>
<p>这种方式填充.</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public boolean stoneGame(int[] piles) &#123;</span><br><span class="line">        int len = piles.length;</span><br><span class="line">        int[][] dp = new int[len][len];</span><br><span class="line">        </span><br><span class="line">        int step = len - 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; len; i++) &#123; // step = 0</span><br><span class="line">            dp[i][i] = piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j-1])</span><br><span class="line">        for(int i = 1; i &lt;= step; i++) &#123;// 其实直接 i &lt; len 就可以了, 但是为了更容易理解, 多赋值了一个 step 变量</span><br><span class="line">            for(int j = 0; i + j &lt; len; j++) &#123;</span><br><span class="line">                dp[j][j + i] = Math.max(piles[j] - dp[j + 1][j + i], piles[j + i] - dp[j][j + i - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">       return dp[0][len - 1] &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://raw.githubusercontent.com/huajiaaa/huajiaaa.github.io/master/picture/LeetCode%20877.%20stone-game.png" alt="一次提交 AC"></p>
<h2 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h2><p><a href="https://leetcode.com/problems/valid-parenthesis-string/" target="_blank" rel="noopener">678. Valid Parenthesis String</a></p>
<p> Given a string containing only three types of characters: ‘(‘, ‘)’ and  ‘*’, write a function to check whether this string is valid. We define  the validity of a string by these rules: </p>
<ol>
<li>Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.</li>
<li>Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.</li>
<li>Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.</li>
<li><code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string.</li>
<li>An empty string is also valid.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(*)&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(*))&quot;</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong></p>
<ol>
<li>The string size will be in the range [1, 100].</li>
</ol>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>题目比较容易理解, 就是判断所给的字符串是否合法, 其中 * 可以是左括号、右括号、或者空字符串.</p>
<p>一开始想着是否又是 DP 的题目, 后来感觉好像没必要, 直接从前往后遍历, 维护着两个变量就行了.</p>
<p>然后来写一下试试..</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public boolean checkValidString(String s) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int star = 0;</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            char c = s.charAt(i);</span><br><span class="line">            if(c == &apos;(&apos;) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; else if(c == &apos;)&apos;) &#123;</span><br><span class="line">                if(left &gt; 0) &#123; // 贪心, 总是优先抵消左括号</span><br><span class="line">                    left--;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if(star-- == 0) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                star++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return left &lt;= star;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次提交没通过, 卡在了 case “(())((())()()(*)(*()(())())())()()((()())((()))(*“ 上</p>
<p>发现问题出现了对右括号的处理上, 不能简单地“贪心”把左括号抵消, 如果把左括号抵消需要让“左括号至右括号之间的 * 号当做空字符串” 才符合规则. 这样看来, 还是得用 dp 来做…</p>
</div><div class="tags"><a href="/tags/算法/">算法</a></div><div class="post-nav"><a class="pre" href="/2020/11/29/Prometheus-tsdb/">Prometheus tsdb</a><a class="next" href="/2020/11/25/读书笔记/">《Prometheus 云原生监控》读书笔记</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '9068028cdf34808763a3',
  clientSecret: '6a7ac29d31bad8013d5348db4292442adfc4c097',
  repo: 'issues',
  owner: 'huajiaaa',
  admin: ['huajiaaa'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"><input type="hidden" name="si" value="http://yoursite.com"><input name="tn" type="hidden" value="bds"><input name="cl" type="hidden" value="3"><input name="ct" type="hidden" value="2097152"><input name="s" type="hidden" value="on"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/life/">life</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/大监控/" style="font-size: 15px;">大监控</a> <a href="/tags/prometheus/" style="font-size: 15px;">prometheus</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>